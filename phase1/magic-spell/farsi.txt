Magic Spell

فرض کنید یک system callعه جادویی به نام magic_spell با شماره‌ی 0xFACADE وجود دارد. این system call سه آرگومانِ
magic_number, address, length
می‌گیرد. address و length مشخص کننده‌ی بازه‌ای از حافظه هستند که از address شروع می‌شود و طولش length بایت ایست.
این syscall بسته به magic_number، عملیاتی جادویی(!) روی بازه‌ی مشخص شده انجام می‌دهد.
به عنوان مثال اگر magic_number برابر 1 باشد همه‌ی حروف کوچک انگلیسی در بازه‌ی مشخص شده را با حرف بزرگ معادلشان جایگزین می‌کند.
همچنین اگر مقدار magic_number برابر 2 باشد محتوای بازه‌ی مشخص شده را برعکس می‌کند.
متاسفانه ما برای مقادیر دیگر magic_number نمی‌دانیم چه عملیاتی انجام می‌شود! حال به شما در ورودی عدد magic_number و یک رشته به نام str از اعداد، حروف کوچک و بزرگ انگلیسی و '_' داده می‌شود. شما باید magic_spell را بر روی رشته‌ی str صدا بزنید و رشته‌ی تغییر یافته را چاپ کنید (دقیت کنید که بازه‌ی شما نباید شامل '\0' آخر رشته باشد)


محدودیت ها:
0 <= magic_number <= 2^64 - 1
1 <= |str| <= 10,000
فقط حروف a-z A-Z 0-9 _ در str موجود هستند. همچنین اگر بازه‌ی داده شده به magic_spell نیز فقط از این حروف تشکیل شده باشد، حاصل magic_spell نیز چنین است.
برای صدا زدن magic_spell کافی است از قواعد صدا زدن دیگر syscall ها پیروی کنید.


ورودی نمونه ۱:
```
1 ILoveLinux
```
خروجی نمونه ۱:
```
ILOVELINUX
```

ورودی نمونه ۲:
```
2 nyeh_HEH0heh
```

خروجی نمونه ۲:
```
heh0HEH_heyn
```


#TODO: نحوه‌ی دقیق کار با شبیه‌ساز
شبیه‌ساز:
یک کد شبیه‌ساز در اختیار شما قرار گرفته که magic_spell را شبیه‌سازی می‌کند و با اجرای کدتان توسط این شبیه‌ساز قابلیت استفاده از magic_spell را دارید. (در این شبیه‌ساز فقط عملیات‌های متناظر با magic_numberهای 1 و 2 پیاده سازی شده است) همچنین با تغییر تابع perform_operation در این شبیه‌ساز امکان تعریف عملیات‌های دلخواه برای magic_number های مختلف را دارید.

